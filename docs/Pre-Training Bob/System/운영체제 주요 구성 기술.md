---
layout: default
title: 운영체재 주요 구성 기술
nav_order: 3

parent: System
grand_parent: Pre-Training Bob

---

##### bob 11th 지원대상자가 이수해야 할 사전 교육에 대한 학습 일지입니다.

-----

# 4. 운영체제의 주요 구성 기술

## 프로세스 관리

### 프로세스: 수행 상태의 프로그램

### 프로세스의 상태 변화
- 생성: 만들어졌지만 OS에 의해 실행 가능한 프로세스 집합에 포함되지 않음
- 준비: 즉시 CPU를 사용할 수 있으며, 사용을 위해 기다리는 상태
- 실행: 현재 CPU를 차지하여 동작 중인 상태
- 대기: 어떤 사건 발생 전까지 실행될 수 없는 상태(from 실행)
- 보류: 프로세스가 디스크 등에 보관되어 있는 상태(from 대기)
- 교착: 결코 일어날 수 없는 사건을 기다리는 상태
- 종료: OS에 의해 프로세스 집합에서 해제된 상태


<br>
### 프로세스 제어블록(PCB)
  - PCB: Process Control Block
  - 프로세스의 상태, Pid, PC(Program Counter), CPU 스케줄링
  - OS는 프로세스의 실행 중단 시, 재실행 시 PCB를 참조한다

<br>
### Thread 와 Task
  - Thread: 프로세스보다 작은 단위. 메모리 상의 task를 유지시키면서 수행
  - Task: 프로세스와 비슷한 개념. Thread의 집합체

<br>
### 프로세스 스케줄링
- 멀티 프로세스 시스템에서 CPU를 사용하는 프로세스 결정(우선순위 결정)
- 스케줄링 종류
  - 장기 스케줄링: 어떤 프로세스를 커널에 등록할 것인가?
  - 중기 스케줄링: 어떤 프로세스에게 메모리를 할당할 것인가?
  - 단기 스케줄링: 어떤 프로세스에게 CPU를 할당할 것인가?
  <br>
- 스케줄링 알고리즘
  - 선점 스케줄링
    - 우선 순위에 따라 CPU를 재배정
    - 실시간 시분할 시스템, 대화형 시분할 시스템
    - PR, SRT, MFQ
    <br>
  - 비선점 스케줄링
    - 이미 할당된 CPU를 뺏지 않음
    - FIFO, SJF

※ 문맥교환(Context Switching): 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정. 오버헤드


### 프로세스간 협조
- 생산자와 소비자 문제
  - 버퍼에 데이터가 없는데 소비자 프로세스가 데이터를 요구할 경우
  - 버퍼에 데이터가 가득찼는데 생산자 프로세스가 데이터를 삽입할 경우
  - 여러 개의 프로세스 동기화 문제
  - 해결법
    - 공유 자원에 대한 관리
    - 세마포어(Semaphore): 여러 프로세스에 대한 접근 제어
    - 뮤텍스(Mutex): 여러 스레드에 대한 접근 제어

<br>

- 임계 영역 문제(Critical Section)
  - 멀티 쓰레드, 프로세스 시의 공유 자원이 동시 변경에 따라 상호 모순이 발생하는 문제
  - 해결법
    - 상호배제: 이미 사용 중인 임계 영역에 다른 프로세스의 접근 제한
    - 진행: 임계 영역에 들어가려는 프로세스 순서 결정
    - 한계대기: 수행을 마친 프로세스의 재진입에 제한을 둠

<br>

- 프로세스 간의 통신
  - 공유 메모리 방식
    - 빠름
    - 통신을 이용하여 데이터를 주고 받음
    - 데이터를 함께 사용함
      - 스레드 간의 공유메모리
      - 프로세스 간의 공유메모리

<br>

  - 메시지 시스템 방식
    - 느림
    - 메일 박스: 송수신에 커널 메세지 버퍼를 활용.
    - 랑데뷰: 극단적으로 buffer 용량이 0인 형태로 구현. 요청 시까지 대기.

<br>

### 교착상태(Deadlock)
- 다중 프로그래밍 시스템에서 서로 다른 프로세스가 일어날 수 없는 사건을 무한정 기다리며 더 이상 진행되지 못하는 상태(circular wait)
- 발생 조건
  - 상호 배제: 동시에 여러 프로세스 사용 불가
  - 점유와 대기: 다른 자원을 점유하면서 자신의 할당 자원 미해제
  - 비중단 조건: 프로세스에 할당된 자원을 끝날 때까지 해제 불가시(비선점)
  - 순환 대기: 프로세스들이 꼬리를 물며 자원을 점유
- 해결 방법
  - 예방
  - 회피
  - 탐지
  - 복구

<br>

## 기억장치 관리
### 계층적 기억장치 구조
- 보조 기억장치/주 기억장치/캐시 기억장치(CPU 내 존재) 
- 기억장치 관리자(Memory Manager)
  - 반입 정책
    - 요구 반입 정책(Demand Fetch Strategy)
    - 예상 반입 정책(Anticipating Fetch Strategy)
  - 배치 정책
    - First-fit: 최초 적합
    - Best-fit:최적 적합
    - Worst-fit: 최악 적합
  - 교체 정책

<br>

### 메모리 단편화 문제
- 내부 단편화: 주기억장치 내 사용자 영역이 실행 프로그램보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 현상
- 외부 단편화: 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적(contiguous)이지 않아 발생하는 현상
- 해결법
  - 압축: 산재한 기억장소를 한 군데로 모음
  - 페이징: 주소공간을 페이지 단위로 나눔
  - 세그먼테이션: 가변분할기법으로 크기를 동적으로 설정되도록 함
  <br>
- 주기억장치 할당의 개념
  - 연속 할당 기법
    - 프로그램을 주기억 장치에 연속으로 할당
    - 단일 분할
      - Overlay: 프로그램을 여러 개의 조각으로 분할하여 적재
      - Swapping: swap in(주->보조)/out(보조->주)을 활용
    - 다중 분할
      - 고정 분할: 고정된 크기로 분할(주기억 장치의 낭비가 많다)
      - 가변 분할: 고정 분할의 단편화를 줄이기 위한 방법
      <br>
  - 분산 할당 기법
    - 프로그램을 특정 단위의 조각으로 나누어 주기억 장치 내에 할당하는 기법
    - 페이징
    - 세그먼테이션

<br>

### 가상기억장치
### 물리적 기억장치의 효율을 위해 논리적으로 확장된 기억장치를 제공
### 요구페이징
- Demand Paging
- 실행할 프로그램 일부만 메모리에 적재  
※ lazy swapper: 그 페이지가 필요하지 않는 한 적재하지 않음

<br>
### 페이지 교체 알고리즘
1. 프로세스에 대한 메모리 참조가 유효한지 무효한지 알아낸다.
2. 무효한 페이지라면 프로세스는 중단된다.
3. 빈공간(Free frame)을 찾는다.
4. 디스크에 새로운 할당 프레임으로 해당 페이지를 읽어들인다.
5. 내부 테이블 수정한다.
6. 중단을 다시 실행한다.
- FIFO
- LRU
- OPT
- CLOCK

<br>

### 스래슁(thrashing)
- 페이지 교체 시 페이지 부재가 너무 많이 발생하여 CPU의 활용도를 떨어뜨리는 현상

<br>
## 디스크와 디스크 스케줄링
### 디스크 공간 할당 기법
- 연속 할당: 블록 단위의 메모리 임의 할당, 내부 단편화 야기
- 연결 할당: 연결 리스트, 순차가 아닌 직접 접근에는 불리
- 인덱스 할당: 색인 블록을 활용, 색인 블록에 대한 공간 낭비 발생 가능성

<br>

### 디스크 스케줄링 기법
1. 하드디스크 검색으로 낭비되는 시간을 최소화
2. 특정한 프로세스의 입출력 요청의 우선순위를 정함
3. 디스크 대역을 실행중인 각 프로세스에 할당
4. 정해진 기안까지 요청을 처리해냄
- FCFS: 요청이 들어온 순서대로 처리
- SSTF: 준비 상태의 트랙 중 현재 헤드가 위치한 트랙에서 가까운 요청 먼저 처리
- SCAN: SSTF와 유사하지만, 진행 방향 상 가장 가까운 요청 먼저 처리
- C-SCAN: SCAN과 유사하지만 헤드가 바깥쪽에서 안쪽으로 이동.

<br>

## 파일시스템 관리
### 파일과 파일구조
- 파일: 서로 연관성 있는 데이터의 집단
- 파일의 구조: 파일을 구성하는 레코드들이 기억장치에 배치되는 방식
  - 순차파일: 물리적인 순서에 따라 저장(자기 테이프, 프린트 출력 등)
  - 인덱스된 순차 파일: 키 값에 따라 논리적인 순서대로 배열
  - 직접 파일: 레코드가 직접 엑세스 기억장치의 물리적 주소를 통해 직접 엑세스

### 디렉토리와 디렉토리 구조
- 디렉토리
  - 레코드의 각 필드에 대한 배열을 보관하는 파일
  - 파일 탐색을 위한 색인

<br>

- 디렉토리 구조
  - 1단계 디렉토리 >> 모든 파일이 같은 디렉토리, 파일 이름 구분 필요
  - 2단계 디렉토리 >> 각 사용자마다 별도의 사용자 파일 디렉토리
  - 트리 구조 디렉토리 >> 사용자들마다 종속 디렉토리 생성
  - 비순환 그래프 디렉토리 >> 디렉토리나 파일 공유를 허용하는 구조
  - 일반적인 그래프 디렉토리 >> 순환 가능 구조
  
### 파일시스템 분석
- OS가 파티션이나 디스크에 파일들을 연속적으로 배열하기 위한 자료구조
(파일들을 디스크에서 구성하는 방식)
- Windows 파일 시스템
  - FAT: File Allocation Table. 하드 디스크에 파일 조각들(클러스터)이 저장된 위치를 가지고 있는 테이블
  - FAT16: 2의 16개 정도의 클러스터를 사용. 하드웨여 용량와 비례 관계로 낭비 요소 발생 
  - FAT32: 클러스터의 수는 작아 효율적이지만, 4G 이상의 파일 처리 불가
  - NTFS: New Technology File System. 파일을 항상 연속적인 블록에 저장하여 엑세스 속도가 빠르며 에러발생 시 데이터 보호 기능 제공. 파일 압축 기능 제공

<br>

- UNIX 계열 파일 시스템
  - 디렉토리 영역: 파일 이름과 inode 영역의 파일 번호 저장
  - inode 영역: 파일번호를 제외한 파일의 모든 정보 저장
  - ex2: 리눅스의 파일 시스템, FSCK(File Sytstem ChecK) 제공
  - ex3: ex2의 FSCK을 보완하기 위해 저널링 제공  
  ※ write 시 로그를 남겨 비정상 셧다운 시 이를 통한 안정적인 복구 

  - ext4: 저컬 체크섬 기능을 추가하여 손상 가능성을 감소
